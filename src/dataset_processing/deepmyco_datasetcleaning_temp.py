# -*- coding: utf-8 -*-
"""DeepMyco-DatasetCleaning-Temp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eu21KV0xe9tMyqEjx0tfEcDjotblnqcB
"""

# =========================================
# 1. Setup & load data
# =========================================
import pandas as pd
import re
import numpy as np
import os

# OPTION A: If your file is in Google Drive
# from google.colab import drive
# drive.mount('/content/drive')
# folder_path = "/content/drive/MyDrive/DeepMyco"  # <-- change to your folder
# input_path = os.path.join(folder_path, "merged_dataset_fungi_cleaned.csv")

# OPTION B: If your file is in the Colab working directory
input_path = "/content/merged_dataset_fungi_cleaned.csv"  # <-- change if needed

df = pd.read_csv(input_path)

if "temperature" not in df.columns:
    raise ValueError("Column 'temperature' not found in the dataset.")

print("Sample raw temperature values BEFORE cleaning:")
print(df["temperature"].value_counts().head(30))

# =========================================
# 2. Temperature parsing helper
#    -> returns a float in °C or NaN
# =========================================

def parse_temperature_to_celsius(value):
    """
    Parse a messy temperature string into a numeric value in °C.
    Handles:
      - '30°C', '30 °C', '30ºC', '30.0', '30 degrees Celsius'
      - '30 ± 2 °C', '25.8 ± 0.6 ºC'  -> central value (first number)
      - '25-29°C', 'from 25 to 55 °C', 'between 22 and 26 °C' -> avg of first two numbers
      - '26/20 °C' (day/night) -> avg of first two numbers
      - 'room temperature' / 'Room temperature' / 'Ambient' -> 25°C
      - 'room temperature to 35 °C' -> avg of 25 and 35
      - Non-temperature or unknown strings -> NaN
    """
    v = str(value).strip()
    low = v.lower()

    # Explicit missing/unknown
    missing_tokens = {
        "not specified", "unspecified", "unknown", "not applicable",
        "not specified (bacteria)", "number not specified", "--",
        "not applicable ", "not applicable.", "not applicable"
    }
    if v == "" or low in missing_tokens:
        return np.nan

    # Obvious non-temperature descriptions
    if any(phrase in low for phrase in [
        "ph levels", "various ph", "nad", "mm", "nitrogen-limiting"
    ]):
        return np.nan

    # Extract all numbers (ignore +/- signs)
    nums = re.findall(r"\d+\.?\d*", v.replace(",", "."))
    nums = [float(x) for x in nums]

    # Tokens that usually mean "range" / multiple temps
    range_tokens = [" to ", "between", "from", "-", "–", "range of", "fluctuated", " and "]

    # Room temperature / ambient handling
    if "room temperature" in low or "ambient" in low:
        has_range_word = any(tok in low for tok in range_tokens)
        if not has_range_word:
            # Plain "room temperature" → assume 25°C
            return 25.0
        else:
            # e.g. "room temperature to 35 °C" -> average of 25 and first explicit number
            if nums:
                return (25.0 + nums[0]) / 2.0
            else:
                return 25.0

    # No numeric info -> can't parse
    if not nums:
        return np.nan

    # Single number and no special patterns → just use it
    if len(nums) == 1:
        return nums[0]

    # ± patterns -> treat first number as central value
    if "±" in v or "+/-" in v:
        return nums[0]

    # Day/night style "26/20 °C": average first two numbers
    if "/" in v and "°" in v:
        return sum(nums[:2]) / 2.0

    # Ranges like "25-29°C", "from 25 to 55 °C", "22-26 °C", etc.
    if any(tok in low for tok in range_tokens):
        return sum(nums[:2]) / 2.0

    # Fallback: use the first number
    return nums[0]

# =========================================
# 3. Apply cleaning to create temperature_C
# =========================================

df["temperature"] = df["temperature"].astype(str).str.strip()
df["temperature_C"] = df["temperature"].apply(parse_temperature_to_celsius)

print("\nSummary of cleaned numeric temperature (°C):")
print(df["temperature_C"].describe())

print("\nNumber of rows with missing temperature_C:", df["temperature_C"].isna().sum())

# Show what raw values failed to parse
unparsed = df.loc[df["temperature_C"].isna(), "temperature"].value_counts()
print("\nRaw temperature strings that were NOT parsed (treated as NaN):")
print(unparsed)

# =========================================
# 4. Save cleaned file
# =========================================

# If you mounted Drive and used folder_path:
# output_path = os.path.join(folder_path, "merged_dataset_temp_cleaned.csv")

output_path = "/content/merged_dataset_temp_cleaned.csv"  # <-- adjust if needed
df.to_csv(output_path, index=False)

print(f"\n✅ Saved dataset with cleaned temperature to: {output_path}")